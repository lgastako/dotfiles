# Copyright 2014 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Common test matrix operations used by Firebase Test Lab commands."""

import collections
import datetime
import os
import time
import uuid

from apitools.base.py import exceptions as apitools_exceptions

from googlecloudsdk.api_lib.test import exit_code
from googlecloudsdk.api_lib.test import util
from googlecloudsdk.calliope import exceptions
from googlecloudsdk.core import log
from googlecloudsdk.core import properties
from googlecloudsdk.core.console import console_io


_DEFAULT_STATUS_INTERVAL_SECS = 6.0
_TIMESTAMP_FORMAT = '%H:%M:%S'


def CreateMatrix(args, context, history_id, gcs_results_root):
  """Creates a new matrix test in Firebase Test Lab from the user's params.

  Args:
    args: an argparse namespace. All the arguments that were provided to this
      gcloud command invocation (i.e. group and command arguments combined).
    context: {str:obj} dict containing the gcloud command context, which
      includes the Testing API client+messages libs generated by Apitools.
    history_id: {str} A history ID to publish Tool Results to.
    gcs_results_root: the root dir for a matrix within the GCS results bucket.

  Returns:
    A TestMatrix object created from the supplied matrix configuration values.
  """
  creator = MatrixCreator(args, context, history_id, gcs_results_root)
  return creator.CreateTestMatrix(uuid.uuid4().hex)


class MatrixCreator(object):
  """Creates a single test matrix based on user-supplied test arguments."""

  def __init__(self, args, context, history_id, gcs_results_root):
    """Construct a MatrixCreator to be used to create a single test matrix.

    Args:
      args: an argparse namespace. All the arguments that were provided to this
        gcloud command invocation (i.e. group and command arguments combined).
      context: {str:obj} dict containing the gcloud command context, which
        includes the Testing API client+messages libs generated by Apitools.
      history_id: {str} A history ID to publish Tool Results to.
      gcs_results_root: the root dir for a matrix within the GCS results bucket.
    """
    self._project = util.GetProject()
    self._args = args
    self._history_id = history_id
    self._gcs_results_root = gcs_results_root
    self._client = context['testing_client']
    self._messages = context['testing_messages']

  def _BuildFileReference(self, filename):
    """Build a FileReference pointing to the GCS copy of an APK/OBB file."""
    return self._messages.FileReference(
        gcsPath=os.path.join(self._gcs_results_root,
                             os.path.basename(filename)))

  def _BuildAndroidInstrumentationTestSpec(self):
    """Build a TestSpecification for an AndroidInstrumentationTest."""
    spec = self._BuildGenericTestSpec()
    spec.androidInstrumentationTest = self._messages.AndroidInstrumentationTest(
        appApk=self._BuildFileReference(self._args.app),
        testApk=self._BuildFileReference(self._args.test),
        appPackageId=self._args.app_package,
        testPackageId=self._args.test_package,
        testRunnerClass=self._args.test_runner_class,
        testTargets=(self._args.test_targets or []))
    return spec

  def _BuildAndroidRoboTestSpec(self):
    """Build a TestSpecification for an AndroidRoboTest."""
    spec = self._BuildGenericTestSpec()

    robo_directives = []
    if self._args.robo_directives:
      for key, value in self._args.robo_directives.iteritems():
        robo_directives.append(
            self._messages.RoboDirective(resourceName=key, inputText=value))

    spec.androidRoboTest = self._messages.AndroidRoboTest(
        appApk=self._BuildFileReference(self._args.app),
        appPackageId=self._args.app_package,
        maxDepth=self._args.max_depth,
        maxSteps=self._args.max_steps,
        appInitialActivity=self._args.app_initial_activity,
        roboDirectives=robo_directives)
    return spec

  def _BuildGenericTestSpec(self):
    """Build a generic TestSpecification without test-type specifics."""
    device_files = []
    if self._args.obb_files:
      for obb_file in self._args.obb_files:
        device_files.append(self._messages.DeviceFile(
            obbFile=self._messages.ObbFile(
                obbFileName=os.path.basename(obb_file),
                obb=self._BuildFileReference(obb_file))))

    environment_variables = []
    if self._args.environment_variables:
      for key, value in self._args.environment_variables.iteritems():
        environment_variables.append(
            self._messages.EnvironmentVariable(
                key=key, value=value))

    directories_to_pull = self._args.directories_to_pull or []

    account = None
    if self._args.auto_google_login:
      account = self._messages.Account(googleAuto=self._messages.GoogleAuto())

    setup = self._messages.TestSetup(
        filesToPush=device_files,
        account=account,
        environmentVariables=environment_variables,
        directoriesToPull=directories_to_pull)

    return self._messages.TestSpecification(
        testTimeout=_ReformatDuration(self._args.timeout),
        testSetup=setup)

  def _TestSpecFromType(self, test_type):
    """Map a test type into its corresponding TestSpecification message ."""
    if test_type == 'instrumentation':
      return self._BuildAndroidInstrumentationTestSpec()
    elif test_type == 'robo':
      return self._BuildAndroidRoboTestSpec()
    else:  # It's a bug in our arg validation if we ever get here.
      raise exceptions.InvalidArgumentException(
          'type', 'Unknown test type "{}".'.format(test_type))

  def _BuildTestMatrix(self, spec):
    """Build just the user-specified parts of a TestMatrix message.

    Args:
      spec: a TestSpecification message corresponding to the test type.

    Returns:
      A TestMatrix message.
    """
    android_matrix = self._messages.AndroidMatrix(
        androidModelIds=self._args.device_ids,
        androidVersionIds=self._args.os_version_ids,
        locales=self._args.locales,
        orientations=self._args.orientations)

    gcs = self._messages.GoogleCloudStorage(gcsPath=self._gcs_results_root)
    hist = self._messages.ToolResultsHistory(projectId=self._project,
                                             historyId=self._history_id)
    results = self._messages.ResultStorage(googleCloudStorage=gcs,
                                           toolResultsHistory=hist)

    return self._messages.TestMatrix(
        testSpecification=spec,
        environmentMatrix=self._messages.EnvironmentMatrix(
            androidMatrix=android_matrix),
        clientInfo=self._messages.ClientInfo(name='gcloud'),
        resultStorage=results)

  def _BuildTestMatrixRequest(self, request_id):
    """Build a TestingProjectsTestMatricesCreateRequest for a test matrix.

    Args:
      request_id: {str} a unique ID for the CreateTestMatrixRequest.

    Returns:
      A TestingProjectsTestMatricesCreateRequest message.
    """
    spec = self._TestSpecFromType(self._args.type)
    return self._messages.TestingProjectsTestMatricesCreateRequest(
        projectId=self._project,
        testMatrix=self._BuildTestMatrix(spec),
        requestId=request_id)

  def CreateTestMatrix(self, request_id):
    """Invoke the Testing service to create a test matrix from the user's args.

    Args:
      request_id: {str} a unique ID for the CreateTestMatrixRequest.

    Returns:
      The TestMatrix response message from the TestMatrices.Create rpc.

    Raises:
      HttpException if the test service reports an HttpError.
    """
    request = self._BuildTestMatrixRequest(request_id)
    log.debug('TestMatrices.Create request:\n{0}\n'.format(request))
    try:
      response = self._client.projects_testMatrices.Create(request)
      log.debug('TestMatrices.Create response:\n{0}\n'.format(response))
    except apitools_exceptions.HttpError as error:
      msg = 'Http error while creating test matrix: ' + util.GetError(error)
      raise exceptions.HttpException(msg)

    log.status.Print('Test [{id}] has been created in the Google Cloud.'
                     .format(id=response.testMatrixId))
    return response


class MatrixMonitor(object):
  """A monitor to follow and possibly cancel a single test matrix invocation.

  Attributes:
    matrix_id: {str} the unique ID of the matrix being monitored.
    completed_matrix_states: the set of TestMatrix.State enums representing all
        final matrix states.
  """

  def __init__(self, matrix_id, test_type, context,
               clock=datetime.datetime.now,
               status_interval_secs=None):
    """Construct a MatrixMonitor to monitor a single test matrix instance.

    Args:
      matrix_id: {str} the unique ID of the matrix being monitored.
      test_type: {str} the type of matrix test being run (e.g. 'robo')
      context: {str:obj} dict containing the gcloud command context, which
        includes the Testing API client & messages libs generated by Apitools.
      clock: injected function which returns a current datetime object when
        called. Used to generate time-stamps on progress messages.
      status_interval_secs: {float} how long to sleep between status checks.
    """
    self.matrix_id = matrix_id
    self._test_type = test_type
    self._client = context['testing_client']
    self._messages = context['testing_messages']
    self._clock = clock
    self._project = util.GetProject()
    self._max_status_length = 0

    if status_interval_secs is not None:
      self._status_interval_secs = status_interval_secs
    else:
      self._status_interval_secs = (
          properties.VALUES.test.matrix_status_interval.GetInt() or
          _DEFAULT_STATUS_INTERVAL_SECS)
      # Poll for matrix status half as fast if the end user is not running in
      # interactive mode (i.e. either sys.stdin or sys.stderr is not a terminal
      # i/o stream) such as when gcloud is called by a CI system like Jenkins).
      # This reduces Testing service load and API quota usage.
      if not console_io.IsInteractive(error=True):
        self._status_interval_secs *= 2

    exec_states = self._messages.TestExecution.StateValueValuesEnum
    self._state_names = {
        exec_states.VALIDATING: 'Validating',
        exec_states.PENDING: 'Pending',
        exec_states.RUNNING: 'Running',
        exec_states.FINISHED: 'Finished',
        exec_states.ERROR: 'Error',
        exec_states.UNSUPPORTED_ENVIRONMENT: 'Unsupported',
        exec_states.INCOMPATIBLE_ENVIRONMENT: 'Incompatible Environment',
        exec_states.INCOMPATIBLE_ARCHITECTURE: 'Incompatible Architecture',
        exec_states.CANCELLED: 'Cancelled',
        exec_states.INVALID: 'Invalid',
        exec_states.TEST_STATE_UNSPECIFIED: '*Unspecified*',
    }
    self._completed_execution_states = set([
        exec_states.FINISHED,
        exec_states.ERROR,
        exec_states.UNSUPPORTED_ENVIRONMENT,
        exec_states.INCOMPATIBLE_ENVIRONMENT,
        exec_states.INCOMPATIBLE_ARCHITECTURE,
        exec_states.CANCELLED,
        exec_states.INVALID,
    ])
    matrix_states = self._messages.TestMatrix.StateValueValuesEnum
    self.completed_matrix_states = set([
        matrix_states.FINISHED,
        matrix_states.ERROR,
        matrix_states.CANCELLED,
        matrix_states.INVALID,
    ])

  def HandleUnsupportedExecutions(self, matrix):
    """Report unsupported device dimensions and return supported test list.

    Args:
      matrix: a TestMatrix message.

    Returns:
      A list of TestExecution messages which have supported dimensions.
    """
    states = self._messages.TestExecution.StateValueValuesEnum
    supported_tests = []
    unsupported_dimensions = set()

    for test in matrix.testExecutions:
      if test.state == states.UNSUPPORTED_ENVIRONMENT:
        unsupported_dimensions.add(_FormatInvalidDimension(test.environment))
      else:
        supported_tests.append(test)

    if unsupported_dimensions:
      log.status.Print(
          'Some device dimensions are not compatible and will be skipped:'
          '\n  {d}'.format(d='\n  '.join(unsupported_dimensions)))
    log.status.Print(
        'Firebase Test Lab will execute your {t} test on {n} device(s).'
        .format(t=self._test_type, n=len(supported_tests)))
    return supported_tests

  def _GetTestExecutionStatus(self, test_id):
    """Fetch the TestExecution state of a specific test within a matrix.

    This method is only intended to be used for a TestMatrix with exactly one
    supported TestExecution. It would be inefficient to use it iteratively on
    a larger TestMatrix.

    Args:
      test_id: ID of the TestExecution status to find.

    Returns:
      The TestExecution message matching the unique test_id.
    """
    matrix = self.GetTestMatrixStatus()
    for test in matrix.testExecutions:
      if test.id == test_id:
        return test
    raise exceptions.ToolException(   # We should never get here.
        'Error: test [{0}] not found in matrix [{1}].'.format(
            test_id, self.matrix_id))

  def MonitorTestExecutionProgress(self, test_id):
    """Monitor and report the progress of a single running test.

    This method prints more detailed test progress messages for the case where
    the matrix has exactly one supported test configuration.

    Args:
      test_id: str, the unique id of the single supported test in the matrix.

    Raises:
      ToolException if the Test service reports a backend error.
    """
    states = self._messages.TestExecution.StateValueValuesEnum
    last_state = ''
    error = ''
    progress = []
    last_progress_len = 0

    while True:
      status = self._GetTestExecutionStatus(test_id)
      timestamp = self._clock().strftime(_TIMESTAMP_FORMAT)
      # Check for optional error and progress details
      details = status.testDetails
      if details:
        error = details.errorMessage or ''
        progress = details.progressMessages or []

      # Progress is cumulative, so only print what's new since the last update.
      for msg in progress[last_progress_len:]:
        log.status.Print('{0} {1}'.format(timestamp, msg.rstrip()))
      last_progress_len = len(progress)

      if status.state == states.ERROR:
        raise exceptions.ToolException(
            'Firebase Test Lab infrastructure failure: {e}'.format(e=error),
            exit_code=exit_code.INFRASTRUCTURE_ERR)

      if status.state == states.UNSUPPORTED_ENVIRONMENT:
        msg = ('Device dimensions are not compatible: {d}. '
               'Please use "gcloud beta test android devices list" to '
               'determine which device dimensions are compatible.'
               .format(d=_FormatInvalidDimension(status.environment)))
        raise exceptions.ToolException(msg, exit_code=exit_code.UNSUPPORTED_ENV)

      # Inform user of test progress, typically PENDING -> RUNNING -> FINISHED
      if status.state != last_state:
        last_state = status.state
        log.status.Print(
            '{0} Test is {1}'.format(timestamp, self._state_names[last_state]))

      if status.state in self._completed_execution_states:
        break

      self._SleepForStatusInterval()

    # Even if the single TestExecution is done, we also need to wait for the
    # matrix to reach a finalized state before monitoring is done.
    matrix = self.GetTestMatrixStatus()
    while matrix.state not in self.completed_matrix_states:
      log.debug('Matrix not yet complete, still in state: %s', matrix.state)
      self._SleepForStatusInterval()
      matrix = self.GetTestMatrixStatus()
    self._LogTestComplete(matrix.state)
    return

  def GetTestMatrixStatus(self):
    """Fetch the response from the GetTestMatrix rpc.

    Returns:
      A TestMatrix message holding the current state of the created tests.

    Raises:
      HttpException if the Test service reports a backend error.
    """
    request = self._messages.TestingProjectsTestMatricesGetRequest(
        projectId=self._project,
        testMatrixId=self.matrix_id)
    try:
      return self._client.projects_testMatrices.Get(request)
    except apitools_exceptions.HttpError as error:
      msg = 'Http error while monitoring test run: ' + util.GetError(error)
      raise exceptions.HttpException(msg)

  def MonitorTestMatrixProgress(self):
    """Monitor and report the progress of multiple running tests in a matrix."""
    while True:
      matrix = self.GetTestMatrixStatus()

      state_counts = collections.defaultdict(int)
      for test in matrix.testExecutions:
        state_counts[test.state] += 1

      self._UpdateMatrixStatus(state_counts)

      if matrix.state in self.completed_matrix_states:
        self._LogTestComplete(matrix.state)
        break
      self._SleepForStatusInterval()

  def _UpdateMatrixStatus(self, state_counts):
    """Update the matrix status line with the current test state counts.

    Example: 'Test matrix status: Finished:5 Running:3 Unsupported:2'

    Args:
      state_counts: {state:count} a dict mapping a test state to its frequency.
    """
    status = []
    timestamp = self._clock().strftime(_TIMESTAMP_FORMAT)
    for state, count in state_counts.iteritems():
      if count > 0:
        status.append('{s}:{c}'.format(s=self._state_names[state], c=count))
    status.sort()
    # Use \r so that the status summary will update on the same console line.
    out = '\r{0} Test matrix status: {1} '.format(timestamp, ' '.join(status))

    # Right-pad with blanks when the status line gets shorter.
    self._max_status_length = max(len(out), self._max_status_length)
    log.status.write(out.ljust(self._max_status_length))

  def _LogTestComplete(self, matrix_state):
    """Let the user know that their test matrix has completed running."""
    log.info('Test matrix completed in state: {0}'.format(matrix_state))
    log.status.Print(
        '\n{0} testing complete.'.format(self._test_type.capitalize()))

  def _SleepForStatusInterval(self):
    time.sleep(self._status_interval_secs)

  def CancelTestMatrix(self):
    """Cancels an in-progress TestMatrix.

    Raises:
      HttpException if the Test service reports a back-end error.
    """
    request = self._messages.TestingProjectsTestMatricesCancelRequest(
        projectId=self._project,
        testMatrixId=self.matrix_id)
    try:
      self._client.projects_testMatrices.Cancel(request)
    except apitools_exceptions.HttpError as error:
      msg = 'Http error from CancelTestMatrix: ' + util.GetError(error)
      raise exceptions.HttpException(msg)


def _FormatInvalidDimension(environment):
  """Return a human-readable string representing an invalid matrix dimension."""
  if hasattr(environment, 'androidDevice'):
    device = environment.androidDevice
    return ('[OS-version {vers} on {model}]'
            .format(model=device.androidModelId, vers=device.androidVersionId))
  else:
    # TODO(user): handle other device environments here (e.g. iOS).
    return '[unknown-environment]'


def _ReformatDuration(duration):
  """Reformat a Duration arg to work around ApiTools non-support of that type.

  Duration args are normally converted to an int in seconds (e.g. --timeout 5m
  becomes args.timeout with int value 300). Duration proto fields are converted
  to type string during discovery doc creation, so we have to convert the int
  back into a string-formatted Duration (i.e. append an 's') before
  passing it to the Testing Service.

  Args:
    duration: {int} the number of seconds in the time duration.

  Returns:
    String representation of the Duration with units of seconds.
  """
  return '{secs}s'.format(secs=duration)
